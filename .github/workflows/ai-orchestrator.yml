name: AI Orchestrator (MVP)
on:
  workflow_dispatch:
    inputs:
      goal:
        description: 'Was soll gebaut werden?'
        required: true
      acceptance:
        description: 'Akzeptanzkriterien (testbar)'
        required: true
      constraints:
        description: 'Constraints & Nicht-Ziele'
        required: false
        default: 'Keine GPL/AGPL; Coverage >= 80%'
      pattern:
        description: 'Blueprint'
        required: false
        default: 'fastapi-api'
        type: choice
        options:
          - fastapi-api
          - cli-tool
          - worker-etl
      service_name:
        description: 'Service/Package-Name'
        required: true
      spec_b64:
        description: "Spec payload (base64-encoded UTF-8 JSON)"
        required: false
        type: string
  issues:
    types: [labeled]
permissions:
  contents: write
  pull-requests: write
concurrency:
  group: ai-orchestrator-${{ github.ref }}
  cancel-in-progress: true
jobs:
  run:
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issues' && contains(github.event.label.name, 'ai:build'))
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: '3.11' }
      - name: Install minimal tooling
        run: |
          python -m pip install -U pip
          pip install pytest pytest-cov
      - name: Configure git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
      - name: Orchestrate (tools/ai_build.py)
        env:
          SPEC_TEXT: '${{ inputs.spec_json }}'
          SPEC_B64:  '${{ inputs.spec_b64 }}'
          SPEC_FILE: spec.json
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ -n "${SPEC_B64:-}" ]; then
            python - <<'PY' > "$SPEC_FILE"
import os, base64, sys
b = os.getenv('SPEC_B64','')
try:
    s = base64.b64decode(b).decode('utf-8-sig')
    sys.stdout.write(s)
except Exception as e:
    sys.stderr.write(f"b64 decode failed: {e}\n")
    sys.exit(1)
PY
          else
            python - <<'PY' > "$SPEC_FILE"
import os, sys
s = os.getenv('SPEC_TEXT','')
# Entferne evtl. BOM
s = s.lstrip('\ufeff')
sys.stdout.write(s)
PY
          fi
          python tools/ai_build.py
      - name: Create PR (fallback via API)
        uses: actions/github-script@v7
        env:
          TARGET_BASE: main
        with:
          script: |
            const {owner, repo} = context.repo;
            // Liste aller Branches, filtere auf feat/ai-
            const branches = await github.paginate(
              github.rest.repos.listBranches,
              { owner, repo, per_page: 100 }
            );
            const ai = branches
              .filter(b => b.name && b.name.startsWith('feat/ai-'))
              .map(b => ({ name: b.name, sha: b.commit?.sha }))
              .filter(b => b.sha);
            if (ai.length === 0) {
              core.notice("Kein 'feat/ai-' Branch gefunden – ggf. keine Änderungen.");
              return;
            }
            // Hole Commit-Daten (Datum) und nimm den jüngsten
            const withDates = [];
            for (const b of ai) {
              try {
                const commit = await github.rest.repos.getCommit({ owner, repo, ref: b.sha });
                withDates.push({ name: b.name, date: new Date(commit.data.commit.author.date).getTime() });
              } catch (e) {
                core.notice(`Commit-Abfrage fehlgeschlagen für ${b.name}: ${e.message}`);
              }
            }
            if (withDates.length === 0) {
              core.notice("Keine datierten Commits gefunden.");
              return;
            }
            withDates.sort((a,b) => a.date - b.date);
            const head = withDates[withDates.length - 1].name;

            // Existiert schon ein offener PR?
            const prs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', head: `${owner}:${head}` });
            if (prs.length > 0) {
              core.summary.addRaw(`Offener PR existiert bereits für **${head}**: ${prs[0].html_url}`).write();
              return;
            }

            // PR anlegen
            try {
              const pr = await github.rest.pulls.create({
                owner, repo, head, base: process.env.TARGET_BASE || 'main',
                title: `AI Build: ${head}`,
                body: 'Automatischer Build (siehe PLAN.md / $GITHUB_STEP_SUMMARY). Bitte QA-Checks abwarten (Score ≥ 95).'
              });
              core.summary.addRaw(`PR erstellt: ${pr.data.html_url}`).write();
            } catch (e) {
              core.notice(`PR-Erstellung übersprungen/fehlgeschlagen: ${e.message}`);
            }
      - name: Summary
        if: always()
        run: |
          echo "### AI Orchestrator" >> $GITHUB_STEP_SUMMARY
          echo "- Event: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY 